# PetitCCompiler

[PetitCCompiler](https://github.com/MrBigoudi/PetitCCompiler.git) is a compiler for a small part of the C programming language that we'll call `PetitC`, made with the `OCaml` language.

---


## Dependencies

- `opam`
- `dune`
- `menhir`
- `ocamllex`
- `ocolor`
- `odoc` 

```sh
$ opam install ocolor odoc
```

---


## How to use the compiler

Check the [howto](HOWTO.md) file.

---


## Typing and Syntax checkers

### Ast

We choose to decorate our abstract syntax tree with the locations of the tokens (from menhir) to display error locations. We only decorated the expressions, the intructions' declarations and functions' declarations to retrieve easily the position informations anywhere in the AST. This makes it easy to return a location, but this location may be to broad. A more precise pinpoint could be achieved. We could also add a visualisation of the error similarly to what `gcc` does (as well as suggestion of a correction of the error).
We added the type `fct` to represent fonctions inside our [environments](#typer). This aims at associate a ID to a function with the returned type of the function as well as the types of each parameters. 


### Lexer

For the lexical analysis, we used `ocamllex`. We are stocking the language's keywords inside a hashing table with a key. This key is the string of the reserved keyword and we are case sensitive (a variable can be named `IF` without causing an error). We are handling three types of lexical errors : illegal integer, illegar character and unfinished comment. Illegal numbers occurs when the integer exceed the 32 bits limit (the exception is raised by the OCaml module `Int32`). Illegal character occurs when a character is not a legal ASCII character. Unfinished comments are quite self-explanatory. 


### Parser

For the syntaxic analysis, we used `menhir`. We didn't implement yet the specific error messages when a syntax error occurs but we are digging the menhir's documentation. We generated a `.messages` and did not fill the messages. We might use the `raw.messages` file to compare our (future) error messages to those generated by `menhir`, to assess the correctness of our errors.


### Typer

For the typer we are using a typed-AST and the typer transforms the AST into the typed version. To achieve this we've decorated the expression with a type. The types of the variables are stored in a environment. To manage the access to variables in different blocks we used two maps (brought by the `Map.Make` module) in a special way. This is what we called `dmap` (which stands for double map). One map of the `dmap` is for what we call the "old environment" which are all the ID that can be accessed within a block without being defined within this block. The other one is the "new environment" which correspond to the IDs defined inside the current block, and can overwrite previously defined ID. By doing specific searches and unions we can propagate this `dmap` through nested blocks using recursion to spread informations.


---


## Code production

TODO
# PetitCCompiler

[PetitCCompiler](https://github.com/MrBigoudi/PetitCCompiler.git) is a compiler for a small part of the C programming language that we'll call `PetitC`, made with the `OCaml` language.

---


## Dependencies

- `opam`
- `dune`
- `menhir`
- `ocamllex`
- `ocolor`
- `odoc` 

```sh
$ opam install ocolor odoc
```

---


## How to use the compiler

Check the [howto](HOWTO.md) file.

---


## Typing and Syntax checkers

### Ast

We choose to decorate our abstract syntax tree with the locations of the tokens (from menhir) to display error locations. We only decorated the expressions, the intructions' declarations and functions' declarations to retrieve easily the position informations anywhere in the AST. This makes it easy to return a location, but this location may be to broad. A more precise pinpoint could be achieved. We could also add a visualisation of the error similarly to what `gcc` does (as well as suggestion of a correction of the error).
We added the type `fct` to represent fonctions inside our [environments](#typer). This aims at associate a ID to a function with the returned type of the function as well as the types of each parameters. 


### Lexer

For the lexical analysis, we used `ocamllex`. We are stocking the language's keywords inside a hashing table with a key. This key is the string of the reserved keyword and we are case sensitive (a variable can be named `IF` without causing an error). We are handling three types of lexical errors : illegal integer, illegar character and unfinished comment. Illegal numbers occurs when the integer exceed the 32 bits limit (the exception is raised by the OCaml module `Int32`). Illegal character occurs when a character is not a legal ASCII character. Unfinished comments are quite self-explanatory. 


### Parser

For the syntaxic analysis, we used `menhir`. We didn't implement yet the specific error messages when a syntax error occurs but we are digging the menhir's documentation. We generated a `.messages` and did not fill the messages. We might use the `raw.messages` file to compare our (future) error messages to those generated by `menhir`, to assess the correctness of our errors.


### Typer

For the typer we are using a typed-AST and the typer transforms the AST into the typed version. To achieve this we've decorated the expression with a type. The types of the variables are stored in a environment. To manage the access to variables in different blocks we used two maps (brought by the `Map.Make` module) in a special way. This is what we called `dmap` (which stands for double map). One map of the `dmap` is for what we call the "old environment" which are all the ID that can be accessed within a block without being defined within this block. The other one is the "new environment" which correspond to the IDs defined inside the current block, and can overwrite previously defined ID. By doing specific searches and unions we can propagate this `dmap` through nested blocks using recursion to spread informations.


---


## Code production

During the typer analysis, we create a `dmap` to map the offset, the depth and the parent name of each variables and functions. We then use these informations during the code production. 

First, we use the offset to reference a variable in the produced assembly code instead of its name, The offset represents the place of the so call variable in the stack relatively to the `rbp` pointer which is saved by the callee. We follow the caller/callee conventions but instead of using registers for the 6 first arguments, each arguments is stack. 

Moreover, after pushing its argument, every caller pushes its static parent's rbp address in the stack using the parent name saved during the typer phase to find it. The first local variable of a function is placed at `-16(rbp)` since the function name is the second thing saved in the stack (after the current rbp) by a callee.

The depth saved during the typer phase is used to get the value (or the address) for nested functions. Indeed, the offset saved during the typer phase depends of another activation table which we need to find in the stack before accessing the variable we want. To find this activation table, we keep a global variable `cur_fun_depth` corresponding to the current function depth and we compare it with the depth saved during the typer to recursively move the correct `rbp` value inside `r8`. We can then use the offset previously saved as a displacement compared to the value stored in `r8`.  